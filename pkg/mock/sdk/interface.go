// Code generated by mockery v1.0.0. DO NOT EDIT.

package sdk

import io "io"
import mock "github.com/stretchr/testify/mock"

import stdsdk "github.com/convox/stdsdk"
import structs "github.com/convox/rack/pkg/structs"

// Interface is an autogenerated mock type for the Interface type
type Interface struct {
	mock.Mock
}

// AppCancel provides a mock function with given fields: name
func (_m *Interface) AppCancel(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppCreate provides a mock function with given fields: name, opts
func (_m *Interface) AppCreate(name string, opts structs.AppCreateOptions) (*structs.App, error) {
	ret := _m.Called(name, opts)

	var r0 *structs.App
	if rf, ok := ret.Get(0).(func(string, structs.AppCreateOptions) *structs.App); ok {
		r0 = rf(name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.App)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.AppCreateOptions) error); ok {
		r1 = rf(name, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppDelete provides a mock function with given fields: name
func (_m *Interface) AppDelete(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppGet provides a mock function with given fields: name
func (_m *Interface) AppGet(name string) (*structs.App, error) {
	ret := _m.Called(name)

	var r0 *structs.App
	if rf, ok := ret.Get(0).(func(string) *structs.App); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.App)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppList provides a mock function with given fields:
func (_m *Interface) AppList() (structs.Apps, error) {
	ret := _m.Called()

	var r0 structs.Apps
	if rf, ok := ret.Get(0).(func() structs.Apps); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Apps)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppLogs provides a mock function with given fields: name, opts
func (_m *Interface) AppLogs(name string, opts structs.LogsOptions) (io.ReadCloser, error) {
	ret := _m.Called(name, opts)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(string, structs.LogsOptions) io.ReadCloser); ok {
		r0 = rf(name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.LogsOptions) error); ok {
		r1 = rf(name, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppMetrics provides a mock function with given fields: name, opts
func (_m *Interface) AppMetrics(name string, opts structs.MetricsOptions) (structs.Metrics, error) {
	ret := _m.Called(name, opts)

	var r0 structs.Metrics
	if rf, ok := ret.Get(0).(func(string, structs.MetricsOptions) structs.Metrics); ok {
		r0 = rf(name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Metrics)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.MetricsOptions) error); ok {
		r1 = rf(name, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppParametersGet provides a mock function with given fields: _a0
func (_m *Interface) AppParametersGet(_a0 string) (map[string]string, error) {
	ret := _m.Called(_a0)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(string) map[string]string); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppParametersSet provides a mock function with given fields: _a0, _a1
func (_m *Interface) AppParametersSet(_a0 string, _a1 map[string]string) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, map[string]string) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppUpdate provides a mock function with given fields: name, opts
func (_m *Interface) AppUpdate(name string, opts structs.AppUpdateOptions) error {
	ret := _m.Called(name, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, structs.AppUpdateOptions) error); ok {
		r0 = rf(name, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BuildCreate provides a mock function with given fields: app, url, opts
func (_m *Interface) BuildCreate(app string, url string, opts structs.BuildCreateOptions) (*structs.Build, error) {
	ret := _m.Called(app, url, opts)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, string, structs.BuildCreateOptions) *structs.Build); ok {
		r0 = rf(app, url, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.BuildCreateOptions) error); ok {
		r1 = rf(app, url, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildCreateUpload provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) BuildCreateUpload(_a0 string, _a1 io.Reader, _a2 structs.BuildCreateOptions) (*structs.Build, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, io.Reader, structs.BuildCreateOptions) *structs.Build); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.Reader, structs.BuildCreateOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildExport provides a mock function with given fields: app, id, w
func (_m *Interface) BuildExport(app string, id string, w io.Writer) error {
	ret := _m.Called(app, id, w)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, io.Writer) error); ok {
		r0 = rf(app, id, w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BuildGet provides a mock function with given fields: app, id
func (_m *Interface) BuildGet(app string, id string) (*structs.Build, error) {
	ret := _m.Called(app, id)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, string) *structs.Build); ok {
		r0 = rf(app, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildImport provides a mock function with given fields: app, r
func (_m *Interface) BuildImport(app string, r io.Reader) (*structs.Build, error) {
	ret := _m.Called(app, r)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, io.Reader) *structs.Build); ok {
		r0 = rf(app, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.Reader) error); ok {
		r1 = rf(app, r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildImportMultipart provides a mock function with given fields: _a0, _a1
func (_m *Interface) BuildImportMultipart(_a0 string, _a1 io.Reader) (*structs.Build, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, io.Reader) *structs.Build); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.Reader) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildImportUrl provides a mock function with given fields: _a0, _a1
func (_m *Interface) BuildImportUrl(_a0 string, _a1 io.Reader) (*structs.Build, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, io.Reader) *structs.Build); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.Reader) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildList provides a mock function with given fields: app, opts
func (_m *Interface) BuildList(app string, opts structs.BuildListOptions) (structs.Builds, error) {
	ret := _m.Called(app, opts)

	var r0 structs.Builds
	if rf, ok := ret.Get(0).(func(string, structs.BuildListOptions) structs.Builds); ok {
		r0 = rf(app, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Builds)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.BuildListOptions) error); ok {
		r1 = rf(app, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildLogs provides a mock function with given fields: app, id, opts
func (_m *Interface) BuildLogs(app string, id string, opts structs.LogsOptions) (io.ReadCloser, error) {
	ret := _m.Called(app, id, opts)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(string, string, structs.LogsOptions) io.ReadCloser); ok {
		r0 = rf(app, id, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.LogsOptions) error); ok {
		r1 = rf(app, id, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildUpdate provides a mock function with given fields: app, id, opts
func (_m *Interface) BuildUpdate(app string, id string, opts structs.BuildUpdateOptions) (*structs.Build, error) {
	ret := _m.Called(app, id, opts)

	var r0 *structs.Build
	if rf, ok := ret.Get(0).(func(string, string, structs.BuildUpdateOptions) *structs.Build); ok {
		r0 = rf(app, id, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.BuildUpdateOptions) error); ok {
		r1 = rf(app, id, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapacityGet provides a mock function with given fields:
func (_m *Interface) CapacityGet() (*structs.Capacity, error) {
	ret := _m.Called()

	var r0 *structs.Capacity
	if rf, ok := ret.Get(0).(func() *structs.Capacity); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Capacity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CertificateApply provides a mock function with given fields: app, service, port, id
func (_m *Interface) CertificateApply(app string, service string, port int, id string) error {
	ret := _m.Called(app, service, port, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, string) error); ok {
		r0 = rf(app, service, port, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CertificateCreate provides a mock function with given fields: pub, key, opts
func (_m *Interface) CertificateCreate(pub string, key string, opts structs.CertificateCreateOptions) (*structs.Certificate, error) {
	ret := _m.Called(pub, key, opts)

	var r0 *structs.Certificate
	if rf, ok := ret.Get(0).(func(string, string, structs.CertificateCreateOptions) *structs.Certificate); ok {
		r0 = rf(pub, key, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Certificate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.CertificateCreateOptions) error); ok {
		r1 = rf(pub, key, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CertificateCreateClassic provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) CertificateCreateClassic(_a0 string, _a1 string, _a2 structs.CertificateCreateOptions) (*structs.Certificate, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *structs.Certificate
	if rf, ok := ret.Get(0).(func(string, string, structs.CertificateCreateOptions) *structs.Certificate); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Certificate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.CertificateCreateOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CertificateDelete provides a mock function with given fields: id
func (_m *Interface) CertificateDelete(id string) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CertificateGenerate provides a mock function with given fields: domains
func (_m *Interface) CertificateGenerate(domains []string) (*structs.Certificate, error) {
	ret := _m.Called(domains)

	var r0 *structs.Certificate
	if rf, ok := ret.Get(0).(func([]string) *structs.Certificate); ok {
		r0 = rf(domains)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Certificate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(domains)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CertificateList provides a mock function with given fields:
func (_m *Interface) CertificateList() (structs.Certificates, error) {
	ret := _m.Called()

	var r0 structs.Certificates
	if rf, ok := ret.Get(0).(func() structs.Certificates); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Certificates)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnvironmentSet provides a mock function with given fields: _a0, _a1
func (_m *Interface) EnvironmentSet(_a0 string, _a1 []byte) (*structs.Release, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Release
	if rf, ok := ret.Get(0).(func(string, []byte) *structs.Release); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []byte) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnvironmentUnset provides a mock function with given fields: _a0, _a1
func (_m *Interface) EnvironmentUnset(_a0 string, _a1 string) (*structs.Release, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Release
	if rf, ok := ret.Get(0).(func(string, string) *structs.Release); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EventSend provides a mock function with given fields: action, opts
func (_m *Interface) EventSend(action string, opts structs.EventSendOptions) error {
	ret := _m.Called(action, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, structs.EventSendOptions) error); ok {
		r0 = rf(action, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilesDelete provides a mock function with given fields: app, pid, files
func (_m *Interface) FilesDelete(app string, pid string, files []string) error {
	ret := _m.Called(app, pid, files)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, []string) error); ok {
		r0 = rf(app, pid, files)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilesDownload provides a mock function with given fields: app, pid, file
func (_m *Interface) FilesDownload(app string, pid string, file string) (io.Reader, error) {
	ret := _m.Called(app, pid, file)

	var r0 io.Reader
	if rf, ok := ret.Get(0).(func(string, string, string) io.Reader); ok {
		r0 = rf(app, pid, file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(app, pid, file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilesUpload provides a mock function with given fields: app, pid, r
func (_m *Interface) FilesUpload(app string, pid string, r io.Reader) error {
	ret := _m.Called(app, pid, r)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, io.Reader) error); ok {
		r0 = rf(app, pid, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FormationGet provides a mock function with given fields: _a0
func (_m *Interface) FormationGet(_a0 string) (structs.Services, error) {
	ret := _m.Called(_a0)

	var r0 structs.Services
	if rf, ok := ret.Get(0).(func(string) structs.Services); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Services)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FormationUpdate provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) FormationUpdate(_a0 string, _a1 string, _a2 structs.ServiceUpdateOptions) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, structs.ServiceUpdateOptions) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) Get(_a0 string, _a1 stdsdk.RequestOptions, _a2 interface{}) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, stdsdk.RequestOptions, interface{}) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Initialize provides a mock function with given fields: opts
func (_m *Interface) Initialize(opts structs.ProviderOptions) error {
	ret := _m.Called(opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(structs.ProviderOptions) error); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InstanceKeyroll provides a mock function with given fields:
func (_m *Interface) InstanceKeyroll() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InstanceList provides a mock function with given fields:
func (_m *Interface) InstanceList() (structs.Instances, error) {
	ret := _m.Called()

	var r0 structs.Instances
	if rf, ok := ret.Get(0).(func() structs.Instances); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Instances)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstanceShell provides a mock function with given fields: id, rw, opts
func (_m *Interface) InstanceShell(id string, rw io.ReadWriter, opts structs.InstanceShellOptions) (int, error) {
	ret := _m.Called(id, rw, opts)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, io.ReadWriter, structs.InstanceShellOptions) int); ok {
		r0 = rf(id, rw, opts)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.ReadWriter, structs.InstanceShellOptions) error); ok {
		r1 = rf(id, rw, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstanceShellClassic provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) InstanceShellClassic(_a0 string, _a1 io.ReadWriter, _a2 structs.InstanceShellOptions) (int, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, io.ReadWriter, structs.InstanceShellOptions) int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, io.ReadWriter, structs.InstanceShellOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstanceTerminate provides a mock function with given fields: id
func (_m *Interface) InstanceTerminate(id string) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ObjectDelete provides a mock function with given fields: app, key
func (_m *Interface) ObjectDelete(app string, key string) error {
	ret := _m.Called(app, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(app, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ObjectExists provides a mock function with given fields: app, key
func (_m *Interface) ObjectExists(app string, key string) (bool, error) {
	ret := _m.Called(app, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(app, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ObjectFetch provides a mock function with given fields: app, key
func (_m *Interface) ObjectFetch(app string, key string) (io.ReadCloser, error) {
	ret := _m.Called(app, key)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(string, string) io.ReadCloser); ok {
		r0 = rf(app, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ObjectList provides a mock function with given fields: app, prefix
func (_m *Interface) ObjectList(app string, prefix string) ([]string, error) {
	ret := _m.Called(app, prefix)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(app, prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ObjectStore provides a mock function with given fields: app, key, r, opts
func (_m *Interface) ObjectStore(app string, key string, r io.Reader, opts structs.ObjectStoreOptions) (*structs.Object, error) {
	ret := _m.Called(app, key, r, opts)

	var r0 *structs.Object
	if rf, ok := ret.Get(0).(func(string, string, io.Reader, structs.ObjectStoreOptions) *structs.Object); ok {
		r0 = rf(app, key, r, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Object)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, io.Reader, structs.ObjectStoreOptions) error); ok {
		r1 = rf(app, key, r, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessExec provides a mock function with given fields: app, pid, command, rw, opts
func (_m *Interface) ProcessExec(app string, pid string, command string, rw io.ReadWriter, opts structs.ProcessExecOptions) (int, error) {
	ret := _m.Called(app, pid, command, rw, opts)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, string, string, io.ReadWriter, structs.ProcessExecOptions) int); ok {
		r0 = rf(app, pid, command, rw, opts)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, io.ReadWriter, structs.ProcessExecOptions) error); ok {
		r1 = rf(app, pid, command, rw, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessGet provides a mock function with given fields: app, pid
func (_m *Interface) ProcessGet(app string, pid string) (*structs.Process, error) {
	ret := _m.Called(app, pid)

	var r0 *structs.Process
	if rf, ok := ret.Get(0).(func(string, string) *structs.Process); ok {
		r0 = rf(app, pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Process)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, pid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessList provides a mock function with given fields: app, opts
func (_m *Interface) ProcessList(app string, opts structs.ProcessListOptions) (structs.Processes, error) {
	ret := _m.Called(app, opts)

	var r0 structs.Processes
	if rf, ok := ret.Get(0).(func(string, structs.ProcessListOptions) structs.Processes); ok {
		r0 = rf(app, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Processes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ProcessListOptions) error); ok {
		r1 = rf(app, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessRun provides a mock function with given fields: app, service, opts
func (_m *Interface) ProcessRun(app string, service string, opts structs.ProcessRunOptions) (*structs.Process, error) {
	ret := _m.Called(app, service, opts)

	var r0 *structs.Process
	if rf, ok := ret.Get(0).(func(string, string, structs.ProcessRunOptions) *structs.Process); ok {
		r0 = rf(app, service, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Process)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.ProcessRunOptions) error); ok {
		r1 = rf(app, service, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessRunAttached provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *Interface) ProcessRunAttached(_a0 string, _a1 string, _a2 io.ReadWriter, _a3 int, _a4 structs.ProcessRunOptions) (int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, string, io.ReadWriter, int, structs.ProcessRunOptions) int); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, io.ReadWriter, int, structs.ProcessRunOptions) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessRunDetached provides a mock function with given fields: _a0, _a1, _a2
func (_m *Interface) ProcessRunDetached(_a0 string, _a1 string, _a2 structs.ProcessRunOptions) (string, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, structs.ProcessRunOptions) string); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, structs.ProcessRunOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessStop provides a mock function with given fields: app, pid
func (_m *Interface) ProcessStop(app string, pid string) error {
	ret := _m.Called(app, pid)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(app, pid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Proxy provides a mock function with given fields: host, port, rw
func (_m *Interface) Proxy(host string, port int, rw io.ReadWriter) error {
	ret := _m.Called(host, port, rw)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, io.ReadWriter) error); ok {
		r0 = rf(host, port, rw)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegistryAdd provides a mock function with given fields: server, username, password
func (_m *Interface) RegistryAdd(server string, username string, password string) (*structs.Registry, error) {
	ret := _m.Called(server, username, password)

	var r0 *structs.Registry
	if rf, ok := ret.Get(0).(func(string, string, string) *structs.Registry); ok {
		r0 = rf(server, username, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Registry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(server, username, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegistryList provides a mock function with given fields:
func (_m *Interface) RegistryList() (structs.Registries, error) {
	ret := _m.Called()

	var r0 structs.Registries
	if rf, ok := ret.Get(0).(func() structs.Registries); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Registries)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegistryRemove provides a mock function with given fields: server
func (_m *Interface) RegistryRemove(server string) error {
	ret := _m.Called(server)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(server)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegistryRemoveClassic provides a mock function with given fields: _a0
func (_m *Interface) RegistryRemoveClassic(_a0 string) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReleaseCreate provides a mock function with given fields: app, opts
func (_m *Interface) ReleaseCreate(app string, opts structs.ReleaseCreateOptions) (*structs.Release, error) {
	ret := _m.Called(app, opts)

	var r0 *structs.Release
	if rf, ok := ret.Get(0).(func(string, structs.ReleaseCreateOptions) *structs.Release); ok {
		r0 = rf(app, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ReleaseCreateOptions) error); ok {
		r1 = rf(app, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseGet provides a mock function with given fields: app, id
func (_m *Interface) ReleaseGet(app string, id string) (*structs.Release, error) {
	ret := _m.Called(app, id)

	var r0 *structs.Release
	if rf, ok := ret.Get(0).(func(string, string) *structs.Release); ok {
		r0 = rf(app, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(app, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseList provides a mock function with given fields: app, opts
func (_m *Interface) ReleaseList(app string, opts structs.ReleaseListOptions) (structs.Releases, error) {
	ret := _m.Called(app, opts)

	var r0 structs.Releases
	if rf, ok := ret.Get(0).(func(string, structs.ReleaseListOptions) structs.Releases); ok {
		r0 = rf(app, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Releases)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ReleaseListOptions) error); ok {
		r1 = rf(app, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleasePromote provides a mock function with given fields: app, id
func (_m *Interface) ReleasePromote(app string, id string) error {
	ret := _m.Called(app, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(app, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResourceCreate provides a mock function with given fields: kind, opts
func (_m *Interface) ResourceCreate(kind string, opts structs.ResourceCreateOptions) (*structs.Resource, error) {
	ret := _m.Called(kind, opts)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, structs.ResourceCreateOptions) *structs.Resource); ok {
		r0 = rf(kind, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ResourceCreateOptions) error); ok {
		r1 = rf(kind, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceCreateClassic provides a mock function with given fields: _a0, _a1
func (_m *Interface) ResourceCreateClassic(_a0 string, _a1 structs.ResourceCreateOptions) (*structs.Resource, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, structs.ResourceCreateOptions) *structs.Resource); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ResourceCreateOptions) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceDelete provides a mock function with given fields: name
func (_m *Interface) ResourceDelete(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResourceGet provides a mock function with given fields: name
func (_m *Interface) ResourceGet(name string) (*structs.Resource, error) {
	ret := _m.Called(name)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string) *structs.Resource); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceLink provides a mock function with given fields: name, app
func (_m *Interface) ResourceLink(name string, app string) (*structs.Resource, error) {
	ret := _m.Called(name, app)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, string) *structs.Resource); ok {
		r0 = rf(name, app)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(name, app)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceList provides a mock function with given fields:
func (_m *Interface) ResourceList() (structs.Resources, error) {
	ret := _m.Called()

	var r0 structs.Resources
	if rf, ok := ret.Get(0).(func() structs.Resources); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Resources)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTypes provides a mock function with given fields:
func (_m *Interface) ResourceTypes() (structs.ResourceTypes, error) {
	ret := _m.Called()

	var r0 structs.ResourceTypes
	if rf, ok := ret.Get(0).(func() structs.ResourceTypes); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.ResourceTypes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceUnlink provides a mock function with given fields: name, app
func (_m *Interface) ResourceUnlink(name string, app string) (*structs.Resource, error) {
	ret := _m.Called(name, app)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, string) *structs.Resource); ok {
		r0 = rf(name, app)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(name, app)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceUpdate provides a mock function with given fields: name, opts
func (_m *Interface) ResourceUpdate(name string, opts structs.ResourceUpdateOptions) (*structs.Resource, error) {
	ret := _m.Called(name, opts)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, structs.ResourceUpdateOptions) *structs.Resource); ok {
		r0 = rf(name, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ResourceUpdateOptions) error); ok {
		r1 = rf(name, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceUpdateClassic provides a mock function with given fields: _a0, _a1
func (_m *Interface) ResourceUpdateClassic(_a0 string, _a1 structs.ResourceUpdateOptions) (*structs.Resource, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *structs.Resource
	if rf, ok := ret.Get(0).(func(string, structs.ResourceUpdateOptions) *structs.Resource); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.Resource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, structs.ResourceUpdateOptions) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceList provides a mock function with given fields: app
func (_m *Interface) ServiceList(app string) (structs.Services, error) {
	ret := _m.Called(app)

	var r0 structs.Services
	if rf, ok := ret.Get(0).(func(string) structs.Services); ok {
		r0 = rf(app)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Services)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(app)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceUpdate provides a mock function with given fields: app, name, opts
func (_m *Interface) ServiceUpdate(app string, name string, opts structs.ServiceUpdateOptions) error {
	ret := _m.Called(app, name, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, structs.ServiceUpdateOptions) error); ok {
		r0 = rf(app, name, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SystemGet provides a mock function with given fields:
func (_m *Interface) SystemGet() (*structs.System, error) {
	ret := _m.Called()

	var r0 *structs.System
	if rf, ok := ret.Get(0).(func() *structs.System); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*structs.System)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemInstall provides a mock function with given fields: w, opts
func (_m *Interface) SystemInstall(w io.Writer, opts structs.SystemInstallOptions) (string, error) {
	ret := _m.Called(w, opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(io.Writer, structs.SystemInstallOptions) string); ok {
		r0 = rf(w, opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(io.Writer, structs.SystemInstallOptions) error); ok {
		r1 = rf(w, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemLogs provides a mock function with given fields: opts
func (_m *Interface) SystemLogs(opts structs.LogsOptions) (io.ReadCloser, error) {
	ret := _m.Called(opts)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(structs.LogsOptions) io.ReadCloser); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(structs.LogsOptions) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemMetrics provides a mock function with given fields: opts
func (_m *Interface) SystemMetrics(opts structs.MetricsOptions) (structs.Metrics, error) {
	ret := _m.Called(opts)

	var r0 structs.Metrics
	if rf, ok := ret.Get(0).(func(structs.MetricsOptions) structs.Metrics); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Metrics)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(structs.MetricsOptions) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemProcesses provides a mock function with given fields: opts
func (_m *Interface) SystemProcesses(opts structs.SystemProcessesOptions) (structs.Processes, error) {
	ret := _m.Called(opts)

	var r0 structs.Processes
	if rf, ok := ret.Get(0).(func(structs.SystemProcessesOptions) structs.Processes); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Processes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(structs.SystemProcessesOptions) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemReleases provides a mock function with given fields:
func (_m *Interface) SystemReleases() (structs.Releases, error) {
	ret := _m.Called()

	var r0 structs.Releases
	if rf, ok := ret.Get(0).(func() structs.Releases); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(structs.Releases)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemUninstall provides a mock function with given fields: name, w, opts
func (_m *Interface) SystemUninstall(name string, w io.Writer, opts structs.SystemUninstallOptions) error {
	ret := _m.Called(name, w, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, io.Writer, structs.SystemUninstallOptions) error); ok {
		r0 = rf(name, w, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SystemUpdate provides a mock function with given fields: opts
func (_m *Interface) SystemUpdate(opts structs.SystemUpdateOptions) error {
	ret := _m.Called(opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(structs.SystemUpdateOptions) error); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Workers provides a mock function with given fields:
func (_m *Interface) Workers() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
